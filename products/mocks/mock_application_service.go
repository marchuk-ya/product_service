// Code generated by MockGen. DO NOT EDIT.
// Source: internal/usecase/ports/application_service.go
//
// Generated by this command:
//
//	mockgen -source=internal/usecase/ports/application_service.go -destination=mocks/mock_application_service.go -package=mocks
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	domain "product_service/products/internal/domain"
	ports "product_service/products/internal/usecase/ports"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockProductApplicationService is a mock of ProductApplicationService interface.
type MockProductApplicationService struct {
	ctrl     *gomock.Controller
	recorder *MockProductApplicationServiceMockRecorder
	isgomock struct{}
}

// MockProductApplicationServiceMockRecorder is the mock recorder for MockProductApplicationService.
type MockProductApplicationServiceMockRecorder struct {
	mock *MockProductApplicationService
}

// NewMockProductApplicationService creates a new mock instance.
func NewMockProductApplicationService(ctrl *gomock.Controller) *MockProductApplicationService {
	mock := &MockProductApplicationService{ctrl: ctrl}
	mock.recorder = &MockProductApplicationServiceMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockProductApplicationService) EXPECT() *MockProductApplicationServiceMockRecorder {
	return m.recorder
}

// CreateProductWithEvent mocks base method.
func (m *MockProductApplicationService) CreateProductWithEvent(ctx context.Context, product *domain.Product, idempotencyKey string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateProductWithEvent", ctx, product, idempotencyKey)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateProductWithEvent indicates an expected call of CreateProductWithEvent.
func (mr *MockProductApplicationServiceMockRecorder) CreateProductWithEvent(ctx, product, idempotencyKey any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateProductWithEvent", reflect.TypeOf((*MockProductApplicationService)(nil).CreateProductWithEvent), ctx, product, idempotencyKey)
}

// DeleteProductWithEvent mocks base method.
func (m *MockProductApplicationService) DeleteProductWithEvent(ctx context.Context, product *domain.Product, idempotencyKey string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteProductWithEvent", ctx, product, idempotencyKey)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteProductWithEvent indicates an expected call of DeleteProductWithEvent.
func (mr *MockProductApplicationServiceMockRecorder) DeleteProductWithEvent(ctx, product, idempotencyKey any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteProductWithEvent", reflect.TypeOf((*MockProductApplicationService)(nil).DeleteProductWithEvent), ctx, product, idempotencyKey)
}

// MockUoWFactory is a mock of UoWFactory interface.
type MockUoWFactory struct {
	ctrl     *gomock.Controller
	recorder *MockUoWFactoryMockRecorder
	isgomock struct{}
}

// MockUoWFactoryMockRecorder is the mock recorder for MockUoWFactory.
type MockUoWFactoryMockRecorder struct {
	mock *MockUoWFactory
}

// NewMockUoWFactory creates a new mock instance.
func NewMockUoWFactory(ctrl *gomock.Controller) *MockUoWFactory {
	mock := &MockUoWFactory{ctrl: ctrl}
	mock.recorder = &MockUoWFactoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUoWFactory) EXPECT() *MockUoWFactoryMockRecorder {
	return m.recorder
}

// CreateUnitOfWork mocks base method.
func (m *MockUoWFactory) CreateUnitOfWork() ports.UnitOfWork {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateUnitOfWork")
	ret0, _ := ret[0].(ports.UnitOfWork)
	return ret0
}

// CreateUnitOfWork indicates an expected call of CreateUnitOfWork.
func (mr *MockUoWFactoryMockRecorder) CreateUnitOfWork() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateUnitOfWork", reflect.TypeOf((*MockUoWFactory)(nil).CreateUnitOfWork))
}

// MockBatchOutboxRepository is a mock of BatchOutboxRepository interface.
type MockBatchOutboxRepository struct {
	ctrl     *gomock.Controller
	recorder *MockBatchOutboxRepositoryMockRecorder
	isgomock struct{}
}

// MockBatchOutboxRepositoryMockRecorder is the mock recorder for MockBatchOutboxRepository.
type MockBatchOutboxRepositoryMockRecorder struct {
	mock *MockBatchOutboxRepository
}

// NewMockBatchOutboxRepository creates a new mock instance.
func NewMockBatchOutboxRepository(ctrl *gomock.Controller) *MockBatchOutboxRepository {
	mock := &MockBatchOutboxRepository{ctrl: ctrl}
	mock.recorder = &MockBatchOutboxRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBatchOutboxRepository) EXPECT() *MockBatchOutboxRepositoryMockRecorder {
	return m.recorder
}

// CheckIdempotencyKey mocks base method.
func (m *MockBatchOutboxRepository) CheckIdempotencyKey(ctx context.Context, idempotencyKey string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckIdempotencyKey", ctx, idempotencyKey)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckIdempotencyKey indicates an expected call of CheckIdempotencyKey.
func (mr *MockBatchOutboxRepositoryMockRecorder) CheckIdempotencyKey(ctx, idempotencyKey any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckIdempotencyKey", reflect.TypeOf((*MockBatchOutboxRepository)(nil).CheckIdempotencyKey), ctx, idempotencyKey)
}

// GetPendingEvents mocks base method.
func (m *MockBatchOutboxRepository) GetPendingEvents(ctx context.Context, limit int) ([]ports.OutboxEvent, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingEvents", ctx, limit)
	ret0, _ := ret[0].([]ports.OutboxEvent)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPendingEvents indicates an expected call of GetPendingEvents.
func (mr *MockBatchOutboxRepositoryMockRecorder) GetPendingEvents(ctx, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingEvents", reflect.TypeOf((*MockBatchOutboxRepository)(nil).GetPendingEvents), ctx, limit)
}

// MarkAsFailed mocks base method.
func (m *MockBatchOutboxRepository) MarkAsFailed(ctx context.Context, eventID int64, retryCount int) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkAsFailed", ctx, eventID, retryCount)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkAsFailed indicates an expected call of MarkAsFailed.
func (mr *MockBatchOutboxRepositoryMockRecorder) MarkAsFailed(ctx, eventID, retryCount any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkAsFailed", reflect.TypeOf((*MockBatchOutboxRepository)(nil).MarkAsFailed), ctx, eventID, retryCount)
}

// MarkAsPublished mocks base method.
func (m *MockBatchOutboxRepository) MarkAsPublished(ctx context.Context, eventID int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkAsPublished", ctx, eventID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkAsPublished indicates an expected call of MarkAsPublished.
func (mr *MockBatchOutboxRepositoryMockRecorder) MarkAsPublished(ctx, eventID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkAsPublished", reflect.TypeOf((*MockBatchOutboxRepository)(nil).MarkAsPublished), ctx, eventID)
}

// MoveToDLQ mocks base method.
func (m *MockBatchOutboxRepository) MoveToDLQ(ctx context.Context, eventID int64, reason string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MoveToDLQ", ctx, eventID, reason)
	ret0, _ := ret[0].(error)
	return ret0
}

// MoveToDLQ indicates an expected call of MoveToDLQ.
func (mr *MockBatchOutboxRepositoryMockRecorder) MoveToDLQ(ctx, eventID, reason any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MoveToDLQ", reflect.TypeOf((*MockBatchOutboxRepository)(nil).MoveToDLQ), ctx, eventID, reason)
}

// SaveEvent mocks base method.
func (m *MockBatchOutboxRepository) SaveEvent(ctx context.Context, event *ports.OutboxEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveEvent", ctx, event)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveEvent indicates an expected call of SaveEvent.
func (mr *MockBatchOutboxRepositoryMockRecorder) SaveEvent(ctx, event any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveEvent", reflect.TypeOf((*MockBatchOutboxRepository)(nil).SaveEvent), ctx, event)
}

// SaveEventsBatch mocks base method.
func (m *MockBatchOutboxRepository) SaveEventsBatch(ctx context.Context, events []*ports.OutboxEvent) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "SaveEventsBatch", ctx, events)
	ret0, _ := ret[0].(error)
	return ret0
}

// SaveEventsBatch indicates an expected call of SaveEventsBatch.
func (mr *MockBatchOutboxRepositoryMockRecorder) SaveEventsBatch(ctx, events any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SaveEventsBatch", reflect.TypeOf((*MockBatchOutboxRepository)(nil).SaveEventsBatch), ctx, events)
}
